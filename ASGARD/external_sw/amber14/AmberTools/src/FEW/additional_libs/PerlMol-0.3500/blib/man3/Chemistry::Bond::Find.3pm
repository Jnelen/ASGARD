.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Find 3"
.TH Find 3 "2016-02-11" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Chemistry::Bond::Find \- Detect bonds in a molecule from atomic 3D coordinates and assign formal bond orders
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Chemistry::Bond::Find \*(Aq:all\*(Aq; # export all available functions
\&
\&    # $mol is a Chemistry::Mol object
\&    find_bonds($mol);
\&    assign_bond_orders($mol);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides functions for detecting the bonds in a molecule from its
3D coordinates by using simple cutoffs, and for guessing the formal bond
orders.
.PP
This module is part of the PerlMol project, <http://www.perlmol.org/>.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
These functions may be exported, although nothing is exported by default.
.ie n .IP """find_bonds($mol, %options)""" 4
.el .IP "\f(CWfind_bonds($mol, %options)\fR" 4
.IX Item "find_bonds($mol, %options)"
Finds and adds the bonds in a molecule. Only use it in molecules that have no 
explicit bonds; for example, after reading a file with 3D coordinates but no
bond orders.
.Sp
Available options:
.RS 4
.IP "tolerance" 4
.IX Item "tolerance"
Defaults to 1.1. Two atoms are considered to be bound if the distance between
them is less than the sum of their covalent radii multiplied by the tolerance.
.IP "margin" 4
.IX Item "margin"
\&\s-1NOTE:\s0 in general setting this option is not recommended, unless you know what
you are doing. It is used by the space partitioning algorithm to determine the
\&\*(L"bucket size\*(R". It defaults to 2 * Rmax * tolerance, where Rmax is the largest
covalent radius among the elements found in the molecule. For example, if a
molecule has C, H, N, O, and I, Rmax = R(I) = 1.33, so the margin defaults to 2
* 1.33 * 1.1 = 2.926. This margin ensures that no bonds are missed by the
partitioning algorithm.
.Sp
Using a smaller value gives faster results, but at the risk of missing some
bonds. In this example, if you are certain that your molecule doesn't contain
I\-I bonds (but it has C\-I bonds), you can set margin to (0.77 + 1.33) * 1.1 =
2.31 and you still won't miss any bonds (0.77 is the radius of carbon).  This
only has a significant impact for molecules with a thousand atoms or more, but
it can reduce the execution time by 50% in some cases.
.IP "orders" 4
.IX Item "orders"
If true, assign the bond orders after finding them, by calling
\&\f(CW\*(C`assign_bond_orders($mol, %opts)\*(C'\fR.
.IP "bond_class" 4
.IX Item "bond_class"
The class that will be used for creating the new bonds. The default is 
Chemistry::Bond.
.RE
.RS 4
.RE
.ie n .IP """assign_bond_orders($mol, %opts)""" 4
.el .IP "\f(CWassign_bond_orders($mol, %opts)\fR" 4
.IX Item "assign_bond_orders($mol, %opts)"
Assign the formal bond orders in a molecule. The bonds must already be defined,
either by \f(CW\*(C`find_bonds\*(C'\fR or because the molecule was read from a file that
included bonds but no bond orders. If the bond orders were already defined
(maybe the molecule came from a file that did include bond orders after all),
the original bond orders are erased and the process begins from scratch. Two
different algorithms are available, and may be selected by using the \*(L"method\*(R"
option:
.Sp
.Vb 2
\&    assign_bond_orders($mol, method => \*(Aqitub\*(Aq);
\&    assign_bond_orders($mol, method => \*(Aqbaber\*(Aq);
.Ve
.RS 4
.IP "itub" 4
.IX Item "itub"
This is the default if no method is specified. Developed from scratch by the
author of this module, this algorithm requires only the connection table
information, and it requires that all hydrogen atoms be explicit. It looks for
an atom with unsatisfied valence, increases a bond order, and then does the
same recursively for the neighbors. If everybody's not happy at the end, it
backtracks and tries another bond. The recursive part does not cover the whole
molecule, but only the contiguous region of \*(L"unhappy\*(R" atoms next to the
starting atom and their neighbors. This permits separating the molecule into
independent regions, so that if one is solved and there's a problem in another,
we don't have to backtrack to the first one.
.Sp
The itub algorithm has the following additional options:
.RS 4
.IP "use_coords" 4
.IX Item "use_coords"
Although the algorithm does not \fIrequire\fR 3D coordinates, it uses them by
default to improve the initial guesses of which bond orders should be
increased. To avoid using coordinates, add the \f(CW\*(C`use_coords\*(C'\fR option with a
false value:
.Sp
.Vb 1
\&    assign_bond_orders($mol, use_coords => 0);
.Ve
.Sp
The results are the same most of the time, but using good coordinates improves
the results for complicated cases such as fused heteroaromatic systems.
.IP "scratch" 4
.IX Item "scratch"
If true, start the bond order assignment from scratch by assuming that all bond
orders are 1. If false, start from the current bond orders and try to fix the
unsatisfied valences. This option is true by default.
.RE
.RS 4
.RE
.IP "baber" 4
.IX Item "baber"
A bond order assignment algorithm based on Baber, J. C.; Hodgkin, E. E.
J. Chem. Inf. Comp. Sci. 1992, 32, 401\-406 (with some interpretation).
.Sp
This algorithm uses the 3D coordinates along with various cutoffs and
confidence formulas to guess the bond orders. It then tries to resolve
conflicts by looping through the atoms (but is not recursive or backtracking).
It does not require explicit hydrogens (although it's better when they are
available) because it was designed for use with real crystallographic data
which often doesn't have hydrogen atoms.
.Sp
This method doesn't always give a good answer, especially for conjugated and
aromatic systems. The variation used in this module adds some random numbers to
resolve some ambiguities and break loops, so the results are not even entirely
deterministic (the 'itub' method is deterministic but the result may depend on
the input order of the atoms).
.RE
.RS 4
.RE
.SH "VERSION"
.IX Header "VERSION"
0.21
.SH "TO DO"
.IX Header "TO DO"
Some future version should let the user specify the desired cutoffs, and 
not always create a bond but call a user-supplied function instead. This way
these functions could be used for other purposes such as finding hydrogen bonds
or neighbor lists.
.PP
Add some tests.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Chemistry::Mol, Chemistry::Atom, Chemistry::Bond,
<http://www.perlmol.org/>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ivan Tubert <itub@cpan.org>
.PP
The new \f(CW\*(C`find_bonds\*(C'\fR algorithm was loosely based on a suggestion by BrowserUK
on perlmonks.org (<http://perlmonks.org/index.pl?node_id=352838>).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004 Ivan Tubert. All rights reserved. This program is free
software; you can redistribute it and/or modify it under the same terms as
Perl itself.
