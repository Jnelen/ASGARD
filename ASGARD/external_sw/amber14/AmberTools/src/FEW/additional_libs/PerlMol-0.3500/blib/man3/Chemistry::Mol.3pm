.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mol 3"
.TH Mol 3 "2016-02-11" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Chemistry::Mol \- Molecule object toolkit
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Chemistry::Mol;
\&
\&    $mol = Chemistry::Mol\->new(id => "mol_id", name => "my molecule");
\&    $c = $mol\->new_atom(symbol => "C", coords => [0,0,0]); 
\&    $o = $mol\->new_atom(symbol => "O", coords => [0,0,1.23]); 
\&    $mol\->new_bond(atoms => [$c, $o], order => 3);
\&
\&    print $mol\->print;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package, along with Chemistry::Atom and Chemistry::Bond, includes basic
objects and methods to describe molecules.
.PP
The core methods try not to enforce a particular convention.  This means that
only a minimal set of attributes is provided by default, and some attributes
have very loosely defined meaning. This is because each program and file type
has different idea of what each concept (such as bond and atom type) means.
Bonds are defined as a list of atoms (typically two) with an arbitrary type.
Atoms are defined by a symbol and a Z, and may have 3D and internal coordinates
(2D coming soon).
.SH "METHODS"
.IX Header "METHODS"
See also Chemistry::Obj for generic attributes.
.IP "Chemistry::Mol\->new(name => value, ...)" 4
.IX Item "Chemistry::Mol->new(name => value, ...)"
Create a new Mol object with the specified attributes.
.Sp
.Vb 1
\&    $mol = Chemistry::Mol\->new(id => \*(Aqm123\*(Aq, name => \*(Aqmy mol\*(Aq)
.Ve
.Sp
is the same as
.Sp
.Vb 3
\&    Chemistry::Mol\->new()
\&    $mol\->id(\*(Aqm123\*(Aq)
\&    $mol\->name(\*(Aqmy mol\*(Aq)
.Ve
.ie n .IP "$mol\->add_atom($atom, ...)" 4
.el .IP "\f(CW$mol\fR\->add_atom($atom, ...)" 4
.IX Item "$mol->add_atom($atom, ...)"
Add one or more Atom objects to the molecule. Returns the last atom added.
.ie n .IP "$mol\->atom_class" 4
.el .IP "\f(CW$mol\fR\->atom_class" 4
.IX Item "$mol->atom_class"
Returns the atom class that a molecule or molecule class expects to use by
default. Chemistry::Mol objects return \*(L"Chemistry::Atom\*(R", but subclasses
will likely override this method.
.ie n .IP "$mol\->new_atom(name => value, ...)" 4
.el .IP "\f(CW$mol\fR\->new_atom(name => value, ...)" 4
.IX Item "$mol->new_atom(name => value, ...)"
Shorthand for \f(CW\*(C`$mol\->add_atom($mol\->atom_class\->new(name => value, ...))\*(C'\fR.
.ie n .IP "$mol\->delete_atom($atom, ...)" 4
.el .IP "\f(CW$mol\fR\->delete_atom($atom, ...)" 4
.IX Item "$mol->delete_atom($atom, ...)"
Deletes an atom from the molecule. It automatically deletes all the bonds in
which the atom participates as well. \f(CW$atom\fR should be a Chemistry::Atom
reference. This method also accepts the atom index, but this use is deprecated
(and buggy if multiple indices are given, unless they are in descending order).
.ie n .IP "$mol\->add_bond($bond, ...)" 4
.el .IP "\f(CW$mol\fR\->add_bond($bond, ...)" 4
.IX Item "$mol->add_bond($bond, ...)"
Add one or more Bond objects to the molecule. Returns the last bond added.
.ie n .IP "$mol\->bond_class" 4
.el .IP "\f(CW$mol\fR\->bond_class" 4
.IX Item "$mol->bond_class"
Returns the bond class that a molecule or molecule class expects to use by
default. Chemistry::Mol objects return \*(L"Chemistry::Bond\*(R", but subclasses
will likely override this method.
.ie n .IP "$mol\->new_bond(name => value, ...)" 4
.el .IP "\f(CW$mol\fR\->new_bond(name => value, ...)" 4
.IX Item "$mol->new_bond(name => value, ...)"
Shorthand for \f(CW\*(C`$mol\->add_bond($mol\->bond_class\->new(name => value, ...))\*(C'\fR.
.ie n .IP "$mol\->delete_bond($bond, ...)" 4
.el .IP "\f(CW$mol\fR\->delete_bond($bond, ...)" 4
.IX Item "$mol->delete_bond($bond, ...)"
Deletes a bond from the molecule. \f(CW$bond\fR should be a Chemistry::Bond object.
.ie n .IP "$mol\->by_id($id)" 4
.el .IP "\f(CW$mol\fR\->by_id($id)" 4
.IX Item "$mol->by_id($id)"
Return the atom or bond object with the corresponding id.
.ie n .IP "$mol\->atoms($n1, ...)" 4
.el .IP "\f(CW$mol\fR\->atoms($n1, ...)" 4
.IX Item "$mol->atoms($n1, ...)"
Returns the atoms with the given indices, or all by default. 
Indices start from one, not from zero.
.ie n .IP "$mol\->atoms_by_name($name)" 4
.el .IP "\f(CW$mol\fR\->atoms_by_name($name)" 4
.IX Item "$mol->atoms_by_name($name)"
Returns the atoms with the given name (treated as an anchored regular
expression).
.ie n .IP "$mol\->sort_atoms($sub_ref)" 4
.el .IP "\f(CW$mol\fR\->sort_atoms($sub_ref)" 4
.IX Item "$mol->sort_atoms($sub_ref)"
Sort the atoms in the molecule by using the comparison function given in
\&\f(CW$sub_ref\fR. This function should take two atoms as parameters and return \-1, 0,
or 1 depending on whether the first atom should go before, same, or after the
second atom. For example, to sort by atomic number, you could use the
following:
.Sp
.Vb 1
\&    $mol\->sort_atoms( sub { $_[0]\->Z <=> $_[1]\->Z } );
.Ve
.Sp
Note that the atoms are passed as parameters and not as the package variables
\&\f(CW$a\fR and \f(CW$b\fR like the core sort function does. This is because \f(CW$mol\fR\->sort will
likely be called from another package and we don't want to play with another
package's symbol table.
.ie n .IP "$mol\->bonds($n1, ...)" 4
.el .IP "\f(CW$mol\fR\->bonds($n1, ...)" 4
.IX Item "$mol->bonds($n1, ...)"
Returns the bonds with the given indices, or all by default.
Indices start from one, not from zero.
.ie n .IP "$mol\->print(option => value...)" 4
.el .IP "\f(CW$mol\fR\->print(option => value...)" 4
.IX Item "$mol->print(option => value...)"
Convert the molecule to a string representation. If no options are given, 
a default YAML-like format is used (this may change in the future). Otherwise,
the format should be specified by using the \f(CW\*(C`format\*(C'\fR option.
.ie n .IP "$s\fR = \f(CW$mol\->sprintf($format)" 4
.el .IP "\f(CW$s\fR = \f(CW$mol\fR\->sprintf($format)" 4
.IX Item "$s = $mol->sprintf($format)"
Format interesting molecular information in a concise way, as specified by
a printf-like format.
.Sp
.Vb 10
\&    %n \- name
\&    %f \- formula 
\&    %f{formula with format} \- (note: right braces within
\&        the format should be escaped with a backslash)
\&    %s \- SMILES representation
\&    %S \- canonical SMILES representation
\&    %m \- mass
\&    %8.3m \- mass, formatted as %8.3f with core sprintf
\&    %q \- formal charge
\&    %a \- atom count
\&    %b \- bond count
\&    %t \- type
\&    %i \- id
\&    %% \- %
.Ve
.Sp
For example, if you want just about everything:
.Sp
.Vb 2
\&    $mol\->sprintf("%s \- %n (%f). %a atoms, %b bonds; "
\&        . "mass=%m; charge =%q; type=%t; id=%i");
.Ve
.Sp
Note that you have to \f(CW\*(C`use Chemistry::File::SMILES\*(C'\fR before using \f(CW%s\fR or
\&\f(CW%S\fR on \f(CW\*(C`$mol\->sprintf\*(C'\fR.
.ie n .IP "$mol\->printf($format)" 4
.el .IP "\f(CW$mol\fR\->printf($format)" 4
.IX Item "$mol->printf($format)"
Same as \f(CW\*(C`$mol\->sprintf\*(C'\fR, but prints to standard output automatically.
Used for quick and dirty molecular information dumping.
.IP "Chemistry::Mol\->parse($string, option => value...)" 4
.IX Item "Chemistry::Mol->parse($string, option => value...)"
Parse the molecule encoded in \f(CW$string\fR. The format should be specified
with the the \f(CW\*(C`format\*(C'\fR option; otherwise, it will be guessed.
.IP "Chemistry::Mol\->read($fname, option => value ...)" 4
.IX Item "Chemistry::Mol->read($fname, option => value ...)"
Read a file and return a list of Mol objects, or croaks if there was a problem.
The type of file will be guessed if not specified via the \f(CW\*(C`format\*(C'\fR option.
.Sp
Note that only registered file readers will be used. Readers may be registered
using \f(CW\*(C`register_type()\*(C'\fR; modules that include readers (such as
Chemistry::File::PDB) usually register them automatically when they are
loaded.
.Sp
Automatic decompression of gzipped files is supported if the Compress::Zlib
module is installed. Files ending in .gz are assumed to be compressed;
otherwise it is possible to force decompression by passing the gzip => 1
option (or no decompression with gzip => 0).
.ie n .IP "$mol\->write($fname, option => value ...)" 4
.el .IP "\f(CW$mol\fR\->write($fname, option => value ...)" 4
.IX Item "$mol->write($fname, option => value ...)"
Write a molecule file, or croak if there was a problem. The type of file will
be guessed if not specified via the \f(CW\*(C`format\*(C'\fR option.
.Sp
Note that only registered file formats will be used.
.Sp
Automatic gzip compression is supported if the IO::Zlib module is installed.
Files ending in .gz are assumed to be compressed; otherwise it is possible to
force compression by passing the gzip => 1 option (or no compression with gzip
=> 0). Specific compression levels between 2 (fastest) and 9 (most compressed)
may also be used (e.g., gzip => 9).
.IP "Chemistry::Mol\->file($file, option => value ...)" 4
.IX Item "Chemistry::Mol->file($file, option => value ...)"
Create a Chemistry::File\-derived object for reading or writing to a file.
The object can then be used to read the molecules or other information in the
file.
.Sp
This has more flexibility than calling \f(CW\*(C`Chemistry::Mol\->read\*(C'\fR when
dealing with multi-molecule files or files that have higher structure or that
have information that does not belong to the molecules themselves. For
example, a reaction file may have a list of molecules, but also general
information like the reaction name, yield, etc. as well as the classification
of the molecules as reactants or products. The exact information that is
available will depend on the file reader class that is being used. The
following is a hypothetical example for reading \s-1MDL\s0 rxnfiles.
.Sp
.Vb 2
\&    # assuming this module existed...
\&    use Chemistry::File::Rxn;
\&
\&    my $rxn = Chemistry::Mol\->file(\*(Aqtest.rxn\*(Aq);
\&    $rxn\->read;
\&    $name      = $rxn\->name;
\&    @reactants = $rxn\->reactants; # mol objects
\&    @products  = $rxn\->products;
\&    $yield     = $rxn\->yield;     # a number
.Ve
.Sp
Note that only registered file readers will be used. Readers may be registered
using \fIregister_type()\fR; modules that include readers (such as
Chemistry::File::PDB) usually register them automatically.
.ie n .IP "Chemistry::Mol\->register_format($name, $ref)" 4
.el .IP "Chemistry::Mol\->register_format($name, \f(CW$ref\fR)" 4
.IX Item "Chemistry::Mol->register_format($name, $ref)"
Register a file type. The identifier \f(CW$name\fR must be unique.  \f(CW$ref\fR is either a
class name (a package) or an object that complies with the Chemistry::File
interface (e.g., a subclass of Chemistry::File).  If \f(CW$ref\fR is omitted, the
calling package is used automatically. More than one format can be registered
at a time, but then \f(CW$ref\fR must be included for each format (e.g.,
Chemistry::Mol\->register_format(format1 => \*(L"package1\*(R", format2 => package2).
.Sp
The typical user doesn't have to care about this function. It is used
automatically by molecule file I/O modules.
.IP "Chemistry::Mol\->formats" 4
.IX Item "Chemistry::Mol->formats"
Returns a list of the file formats that have been installed by
\&\fIregister_type()\fR
.ie n .IP "$mol\->mass" 4
.el .IP "\f(CW$mol\fR\->mass" 4
.IX Item "$mol->mass"
Return the molar mass. This is just the sum of the masses of the atoms.  See
Chemistry::Atom::mass for details such as the handling of isotopes.
.ie n .IP "$mol\->charge" 4
.el .IP "\f(CW$mol\fR\->charge" 4
.IX Item "$mol->charge"
Return the charge of the molecule. By default it returns the sum of the formal
charges of the atoms. However, it is possible to set an arbitrary charge by
calling \f(CW\*(C`$mol\->charge($new_charge)\*(C'\fR
.ie n .IP "$mol\->formula_hash" 4
.el .IP "\f(CW$mol\fR\->formula_hash" 4
.IX Item "$mol->formula_hash"
Returns a hash reference describing the molecular formula. For methane it would
return { C => 1, H => 4 }.
.ie n .IP "$mol\->formula($format)" 4
.el .IP "\f(CW$mol\fR\->formula($format)" 4
.IX Item "$mol->formula($format)"
Returns a string with the formula. The format can be specified as a printf-like
string with the control sequences specified in the Chemistry::File::Formula
documentation.
.ie n .IP "my $mol2\fR = \f(CW$mol\->clone;" 4
.el .IP "my \f(CW$mol2\fR = \f(CW$mol\fR\->clone;" 4
.IX Item "my $mol2 = $mol->clone;"
Makes a copy of a molecule. Note that this is a \fBdeep\fR copy; if your molecule
has a pointer to the rest of the universe, the entire universe will be cloned!
.ie n .IP "my $mol2\fR = \f(CW$mol\->safe_clone;" 4
.el .IP "my \f(CW$mol2\fR = \f(CW$mol\fR\->safe_clone;" 4
.IX Item "my $mol2 = $mol->safe_clone;"
Like clone, it makes a deep copy of a molecule. The difference is that the copy
is not \*(L"exact\*(R" in that new molecule and its atoms and bonds get assigned new
IDs. This makes it safe to combine cloned molecules. For example, this is an
error:
.Sp
.Vb 3
\&    # XXX don\*(Aqt try this at home!
\&    my $mol2 = Chemistry::Mol\->combine($mol1, $mol1);
\&    # the atoms in $mol1 will clash
.Ve
.Sp
But this is ok:
.Sp
.Vb 2
\&    # the "safe clone" of $mol1 will have new IDs
\&    my $mol2 = Chemistry::Mol\->combine($mol1, $mol1\->safe_clone);
.Ve
.ie n .IP "($distance, $atom_here\fR, \f(CW$atom_there\fR) = \f(CW$mol\->distance($obj)" 4
.el .IP "($distance, \f(CW$atom_here\fR, \f(CW$atom_there\fR) = \f(CW$mol\fR\->distance($obj)" 4
.IX Item "($distance, $atom_here, $atom_there) = $mol->distance($obj)"
Returns the minimum distance to \f(CW$obj\fR, which can be an atom, a molecule, or a
vector. In scalar context it returns only the distance; in list context it
also returns the atoms involved. The current implementation for calculating
the minimum distance between two molecules compares every possible pair of
atoms, so it's not efficient for large molecules.
.ie n .IP "my $bigmol\fR = Chemistry::Mol\->combine($mol1, \f(CW$mol2, ...)" 4
.el .IP "my \f(CW$bigmol\fR = Chemistry::Mol\->combine($mol1, \f(CW$mol2\fR, ...)" 4
.IX Item "my $bigmol = Chemistry::Mol->combine($mol1, $mol2, ...)"
.PD 0
.ie n .IP "$mol1\fR\->combine($mol2, \f(CW$mol3, ...)" 4
.el .IP "\f(CW$mol1\fR\->combine($mol2, \f(CW$mol3\fR, ...)" 4
.IX Item "$mol1->combine($mol2, $mol3, ...)"
.PD
Combines several molecules in one bigger molecule. If called as a class method,
as in the first example, it returns a new combined molecule without altering
any of the parameters. If called as an instance method, as in the second
example, all molecules are combined into \f(CW$mol1\fR (but \f(CW$mol2\fR, \f(CW$mol3\fR, ...) are not
altered. \fBNote\fR: Make sure you don't combine molecules which contain atoms
with duplicate IDs (for example, if they were cloned).
.ie n .IP "my @mols\fR = \f(CW$mol\->separate" 4
.el .IP "my \f(CW@mols\fR = \f(CW$mol\fR\->separate" 4
.IX Item "my @mols = $mol->separate"
Separates a molecule into \*(L"connected fragments\*(R". The original object is not
modified; the fragments are clones of the original ones. Example: if you have
ethane (H3CCH3) and you delete the C\-C bond, you have two \s-1CH3\s0 radicals within
one molecule object ($mol). When you call \f(CW$mol\fR\->separate you get two molecules,
each one with a \s-1CH3\s0.
.ie n .IP "$mol\->sprout_hydrogens" 4
.el .IP "\f(CW$mol\fR\->sprout_hydrogens" 4
.IX Item "$mol->sprout_hydrogens"
Convert all the implicit hydrogen atoms in the molecule to explicit atoms.
It does \fBnot\fR generate coordinates for the atoms.
.ie n .IP "$mol\->collapse_hydrogens" 4
.el .IP "\f(CW$mol\fR\->collapse_hydrogens" 4
.IX Item "$mol->collapse_hydrogens"
Convert all the explicit hydrogen atoms in the molecule to implicit hydrogens.
(Exception: hydrogen atoms that are adjacent to a hydrogen atom are not
collapsed.)
.ie n .IP "$mol\->add_implicit_hydrogens" 4
.el .IP "\f(CW$mol\fR\->add_implicit_hydrogens" 4
.IX Item "$mol->add_implicit_hydrogens"
Use heuristics to figure out how many implicit hydrogens should each atom in 
the molecule have to satisfy its normal \*(L"organic\*(R" valence.
.SH "VERSION"
.IX Header "VERSION"
0.35
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Chemistry::Atom, Chemistry::Bond, Chemistry::File,
Chemistry::Tutorial
.PP
The PerlMol website <http://www.perlmol.org/>
.SH "AUTHOR"
.IX Header "AUTHOR"
Ivan Tubert-Brohman <itub@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2005 Ivan Tubert-Brohman. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same terms as
Perl itself.
