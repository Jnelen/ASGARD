.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File 3"
.TH File 3 "2016-02-11" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Chemistry::File \- Molecule file I/O base class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # As a convenient interface for several mol readers:
\&    use Chemistry::File qw(PDB MDLMol); # load PDB and MDL modules
\&    
\&    # or try to use every file I/O module installed in the system:
\&    use Chemistry::File \*(Aq:auto\*(Aq;
\&
\&    my $mol1 = Chemistry::Mol\->read("file.pdb");
\&    my $mol2 = Chemistry::Mol\->read("file.mol");
\&
\&
\&    # as a base for a mol reader:
\&
\&    package Chemistry::File::Myfile;
\&    use base qw(Chemistry::File);
\&    Chemistry::Mol\->register_type("myfile", _\|_PACKAGE_\|_);
\&
\&    # override the read_mol method
\&    sub read_mol {
\&        my ($self, $fh, %opts) = shift;
\&        my $mol_class = $opts{mol_class} || "Chemistry::Mol";
\&        my $mol = $mol_class\->new;
\&        # ... do some stuff with $fh and $mol ...
\&        return $mol;
\&    }
\&
\&    # override the write_mol method
\&    sub write_mol {
\&        my ($self, $fh, $mol, %opts) = shift;
\&        print $fh $mol\->name, "\en"; 
\&        # ... do some stuff with $fh and $mol ...
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The main use of this module is as a base class for other molecule file I/O
modules (for example, Chemistry::File::PDB). Such modules should override and
extend the Chemistry::File methods as needed. You only need to care about the
methods here if if you are writing a file I/O module or if you want a finer
degree of control than what is offered by the simple read and write methods
in the Chemistry::Mol class.
.PP
From the user's point of view, this module can also be used as shorthand
for using several Chemistry::File modules at the same time.
.PP
.Vb 1
\&    use Chemistry::File qw(PDB MDLMol);
.Ve
.PP
is exactly equivalent to
.PP
.Vb 2
\&    use Chemistry::File::PDB;
\&    use Chemistry::File::MDLMol;
.Ve
.PP
If you use the :auto keyword, Chemistry::File will autodetect and load
all the Chemistry::File::* modules installed in your system.
.PP
.Vb 1
\&    use Chemistry::File \*(Aq:auto\*(Aq;
.Ve
.SH "FILE I/O MODEL"
.IX Header "FILE I/O MODEL"
Before version 0.30, file I/O modules typically used only parse_string,
write_string, parse_file, and write_file, and they were generally used as class
methods. A file could contain one or more molecules and only be read or written
whole; reading it would return every molecule on the file. This was problematic
when dealing with large multi-molecule files (such as \s-1SDF\s0 files), because all
the molecules would have to be loaded into memory at the same time.
.PP
While version 0.30 retains backward compatibility with that simple model, it
also allows a more flexible interface that allows reading one molecule at a
time, skipping molecules, and reading and writing file-level information that
is not associated with specific molecules. The following diagram shows the
global structure of a file according to the new model:
.PP
.Vb 11
\&    +\-\-\-\-\-\-\-\-\-\-\-+
\&    | header    |
\&    +\-\-\-\-\-\-\-\-\-\-\-+
\&    | molecule  |
\&    +\-\-\-\-\-\-\-\-\-\-\-+
\&    | molecule  |
\&    +\-\-\-\-\-\-\-\-\-\-\-+
\&    | ...       |
\&    +\-\-\-\-\-\-\-\-\-\-\-+
\&    | footer    |
\&    +\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
In cases where the header and the footer are empty, the model reduces to the
pre\-0.30 version. The low-level steps to read a file are the following:
.PP
.Vb 7
\&    $file = Chemistry::File::MyFormat\->new(file => \*(Aqxyz.mol\*(Aq);
\&    $file\->open(\*(Aq<\*(Aq);
\&    $file\->read_header;
\&    while (my $mol = $self\->read_mol($file\->fh, %opts)) {
\&        # do something with $mol...
\&    }
\&    $self\->read_footer;
.Ve
.PP
The \f(CW\*(C`read\*(C'\fR method does all the above automatically, and it stores all the
molecules read in the mols property.
.SH "STANDARD OPTIONS"
.IX Header "STANDARD OPTIONS"
All the methods below include a list of options \f(CW%opts\fR at the end of the
parameter list. Each class implementing this interface may have its own
particular options. However, the following options should be recognized by all
classes:
.IP "mol_class" 4
.IX Item "mol_class"
A class or object with a \f(CW\*(C`new\*(C'\fR method that constructs a molecule. This is 
needed when the user want to specify a molecule subclass different from the
default. When this option is not defined, the module may use Chemistry::Mol 
or whichever class is appropriate for that file format.
.IP "format" 4
.IX Item "format"
The name of the file format being used, as registered by
Chemistry::Mol\->register_format.
.IP "fatal" 4
.IX Item "fatal"
If true, parsing errors should throw an exception; if false, they should just
try to recover if possible. True by default.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
The class methods in this class (or rather, its derived classes) are usually
not called directly. Instead, use Chemistry::Mol\->read, write, print, parse,
and file. These methods also work if called as instance methods.
.ie n .IP "$class\fR\->parse_string($s, \f(CW%options)" 4
.el .IP "\f(CW$class\fR\->parse_string($s, \f(CW%options\fR)" 4
.IX Item "$class->parse_string($s, %options)"
Parse a string \f(CW$s\fR and return one or mole molecule objects. This is an abstract
method, so it should be provided by all derived classes.
.ie n .IP "$class\fR\->write_string($mol, \f(CW%options)" 4
.el .IP "\f(CW$class\fR\->write_string($mol, \f(CW%options\fR)" 4
.IX Item "$class->write_string($mol, %options)"
Convert a molecule to a string. This is an abstract method, so it should be
provided by all derived classes.
.ie n .IP "$class\fR\->parse_file($file, \f(CW%options)" 4
.el .IP "\f(CW$class\fR\->parse_file($file, \f(CW%options\fR)" 4
.IX Item "$class->parse_file($file, %options)"
Reads the file \f(CW$file\fR and returns one or more molecules. The default method
slurps the whole file and then calls parse_string, but derived classes may
choose to override it. \f(CW$file\fR can be a filehandle, a filename, or a scalar
reference. See \f(CW\*(C`new\*(C'\fR for details.
.ie n .IP "$class\fR\->write_file($mol, \f(CW$file\fR, \f(CW%options)" 4
.el .IP "\f(CW$class\fR\->write_file($mol, \f(CW$file\fR, \f(CW%options\fR)" 4
.IX Item "$class->write_file($mol, $file, %options)"
Writes a file \f(CW$file\fR containing the molecule \f(CW$mol\fR. The default method calls
write_string first and then saves the string to a file, but derived classes
may choose to override it. \f(CW$file\fR can be either a filehandle or a filename.
.ie n .IP "$class\fR\->name_is($fname, \f(CW%options)" 4
.el .IP "\f(CW$class\fR\->name_is($fname, \f(CW%options\fR)" 4
.IX Item "$class->name_is($fname, %options)"
Returns true if a filename is of the format corresponding to the class.
It should look at the filename only, because it may be called with
non-existent files. It is used to determine with which format to save a file.
For example, the Chemistry::File::PDB returns true if the file ends in .pdb.
.ie n .IP "$class\fR\->string_is($s, \f(CW%options)" 4
.el .IP "\f(CW$class\fR\->string_is($s, \f(CW%options\fR)" 4
.IX Item "$class->string_is($s, %options)"
Examines the string \f(CW$s\fR and returns true if it has the format of the class.
.ie n .IP "$class\fR\->file_is($file, \f(CW%options)" 4
.el .IP "\f(CW$class\fR\->file_is($file, \f(CW%options\fR)" 4
.IX Item "$class->file_is($file, %options)"
Examines the file \f(CW$file\fR and returns true if it has the format of the class.
The default method slurps the whole file and then calls string_is, but derived
classes may choose to override it.
.ie n .IP "$class\fR\->slurp($file \f(CW%opts)" 4
.el .IP "\f(CW$class\fR\->slurp($file \f(CW%opts\fR)" 4
.IX Item "$class->slurp($file %opts)"
Reads a file into a scalar. Automatic decompression of gzipped files is
supported if the Compress::Zlib module is installed. Files ending in .gz are
assumed to be compressed; otherwise it is possible to force decompression by
passing the gzip => 1 option (or no decompression with gzip => 0).
.ie n .IP "$class\fR\->new(file => \f(CW$file, opts => \e%opts)" 4
.el .IP "\f(CW$class\fR\->new(file => \f(CW$file\fR, opts => \e%opts)" 4
.IX Item "$class->new(file => $file, opts => %opts)"
Create a new file object. This method is usually called indirectly via
the Chemistry::Mol\->file method. \f(CW$file\fR may be a scalar with a filename, an
open filehandle, or a reference to a scalar. If a reference to a scalar is 
used, the string contained in the scalar is used as an in-memory file.
.SH "INSTANCE METHODS"
.IX Header "INSTANCE METHODS"
.Sh "Accessors"
.IX Subsection "Accessors"
Chemistry::File objects are derived from Chemistry::Obj and have the same
properties (name, id, and type), as well as the following ones:
.IP "file" 4
.IX Item "file"
The \*(L"file\*(R" as described above under \f(CW\*(C`new\*(C'\fR.
.IP "fh" 4
.IX Item "fh"
The filehandle used for reading and writing molecules. It is opened by \f(CW\*(C`open\*(C'\fR.
.IP "opts" 4
.IX Item "opts"
A hashref containing the options that are passed through to the old-style class
methods. They are also passed to the instance method to keep a similar
interface, but they could access them via \f(CW$self\fR\->opts anyway.
.IP "mode" 4
.IX Item "mode"
\&'>' if the file is open for writing, '<' for reading, and false if not open.
.IP "mols" 4
.IX Item "mols"
\&\f(CW\*(C`read\*(C'\fR stores all the molecules that were read in this property as an array
reference. \f(CW\*(C`write\*(C'\fR gets the molecules to write from here.
.Sh "Abstract methods"
.IX Subsection "Abstract methods"
These methods should be overridden, because they don't really do much by
default.
.ie n .IP "$file\->read_header" 4
.el .IP "\f(CW$file\fR\->read_header" 4
.IX Item "$file->read_header"
Read whatever information is available in the file before the first molecule.
Does nothing by default.
.ie n .IP "$file\->read_footer" 4
.el .IP "\f(CW$file\fR\->read_footer" 4
.IX Item "$file->read_footer"
Read whatever information is available in the file after the last molecule.
Does nothing by default.
.ie n .IP "$self\->slurp_mol($fh)" 4
.el .IP "\f(CW$self\fR\->slurp_mol($fh)" 4
.IX Item "$self->slurp_mol($fh)"
Reads from the input string until the end of the current molecule and returns
the \*(L"slurped\*(R" string. It does not parse the string. It returns undefined if
there are no more molecules in the file. This method should be overridden if
needed; by default, it slurps until the end of the file.
.ie n .IP "$self\->skip_mol($fh)" 4
.el .IP "\f(CW$self\fR\->skip_mol($fh)" 4
.IX Item "$self->skip_mol($fh)"
Similar to slurp_mol, but it doesn't need to return anything except true or 
false. It should also be overridden if needed; by default, it just calls 
slurp_mol.
.ie n .IP "$file\fR\->read_mol($fh, \f(CW%opts)" 4
.el .IP "\f(CW$file\fR\->read_mol($fh, \f(CW%opts\fR)" 4
.IX Item "$file->read_mol($fh, %opts)"
Read the next molecule in the input stream. It returns false if there are no
more molecules in the file. This method should be overridden by derived
classes; otherwise it will call slurp_mol and parse_string (for backwards
compatibility; it is recommended to override read_mol directly in new modules).
.Sp
Note: some old file I/O modules (written before the 0.30 interface) may return
more than one molecule anyway, so it is recommended to call read_mol in list
context to be safe:
.Sp
.Vb 1
\&    ($mol) = $file\->read_mol($fh, %opts);
.Ve
.ie n .IP "$file\->write_header" 4
.el .IP "\f(CW$file\fR\->write_header" 4
.IX Item "$file->write_header"
Write whatever information is needed before the first molecule.
Does nothing by default.
.ie n .IP "$file\->write_footer" 4
.el .IP "\f(CW$file\fR\->write_footer" 4
.IX Item "$file->write_footer"
Write whatever information is needed after the last molecule.
Does nothing by default.
.ie n .IP "$self\fR\->write_mol($fh, \f(CW$mol\fR, \f(CW%opts)" 4
.el .IP "\f(CW$self\fR\->write_mol($fh, \f(CW$mol\fR, \f(CW%opts\fR)" 4
.IX Item "$self->write_mol($fh, $mol, %opts)"
Write one molecule to \f(CW$fh\fR. By default and for backward compatibility, it just
calls \f(CW\*(C`write_string\*(C'\fR and prints its return value to \f(CW$self\fR\->fh. New classes
should override it.
.Sh "Other methods"
.IX Subsection "Other methods"
.ie n .IP "$self\->open($mode)" 4
.el .IP "\f(CW$self\fR\->open($mode)" 4
.IX Item "$self->open($mode)"
Opens the file (held in \f(CW$self\fR\->file) for reading by default, or for writing if
\&\f(CW$mode\fR eq '>'. This method sets \f(CW$self\fR\->fh transparently regardless of whether
\&\f(CW$self\fR\->file is a filename (compressed or not), a scalar reference, or a
filehandle.
.ie n .IP "$self\->close" 4
.el .IP "\f(CW$self\fR\->close" 4
.IX Item "$self->close"
Close the file. For regular files this just closes the filehandle, but for
gzipped files it does some additional postprocessing. This method is called
automatically on object destruction, so it is not mandatory to call it
explicitly.
.ie n .IP "$file\->read" 4
.el .IP "\f(CW$file\fR\->read" 4
.IX Item "$file->read"
Read the whole file. This calls open, read_header, read_mol until there are no
more molecules left, read_footer, and close. Returns a list of molecules if
called in list context, or the first molecule in scalar context.
.ie n .IP "$self\->write" 4
.el .IP "\f(CW$self\fR\->write" 4
.IX Item "$self->write"
Write all the molecules in \f(CW$self\fR\->mols. It just calls open, write_header, 
write_mol (per each molecule), write_footer, and close.
.SH "CAVEATS"
.IX Header "CAVEATS"
The :auto feature may not be entirely portable, but it is known to work under
Unix and Windows (either Cygwin or Activestate).
.SH "VERSION"
.IX Header "VERSION"
0.35
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Chemistry::Mol
.PP
The PerlMol website <http://www.perlmol.org/>
.SH "AUTHOR"
.IX Header "AUTHOR"
Ivan Tubert-Brohman-Brohman <itub@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2005 Ivan Tubert-Brohman. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same terms as
Perl itself.
