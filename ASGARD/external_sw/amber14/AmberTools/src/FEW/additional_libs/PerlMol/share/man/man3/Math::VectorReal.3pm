.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "VectorReal 3"
.TH VectorReal 3 "2016-02-11" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::VectorReal \- Module to handle 3D Vector Mathematics
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    #!/usr/bin/perl
\&    use Math::VectorReal;
\&
\&    $a = vector( 1, 2, .5 );
\&    print "Vector as string (MatrixReal default format)\en\e$a => ", $a;
\&
\&    print  $a\->stringify("Formated Output   \e$a => { %g, %g, %g }\en");
\&
\&    # I hate newline in the default output format (defined as MatrixReal)
\&    $Math::VectorReal::FORMAT = "[ %.5f %.5f %.5f ]";
\&    print "Modified default output format   \e$a => $a\en";
\&
\&    print \*(Aqlength     => \*(Aq, $a\->length, "\en";
\&    print \*(Aqnormalised => \*(Aq, $a\->norm, "\en";
\&
\&    use Math::VectorReal qw(:all);  # Include O X Y Z axis constant vectors
\&    print \*(Aqstring concat   $a."**" = \*(Aq, $a."**", "\en";
\&    print \*(Aqvector constant    X    = \*(Aq,   X,    "\en";
\&    print \*(Aqsubtraction     $a \- Z  = \*(Aq, $a \- Z, "\en";
\&    print \*(Aqscalar divide   $a / 3  = \*(Aq, $a / 3, "\en";
\&    print \*(Aqdot product     $a . Y  = \*(Aq, $a . Y, "\en";
\&    print \*(Aqcross product   $a x Y  = \*(Aq, $a x Y, "\en";
\&
\&    print "Plane containing points X, \e$a, Z (in anti\-clockwise order)\en";
\&    ($n,$d) = plane( X, $a, Z ); # return normal and disance from O
\&    print \*(Aq      normal      =    $n     = \*(Aq, $n, "\en";
\&    print \*(Aq  disance from O  =    $d     = \*(Aq, $d, "\en";
\&    print \*(Aq Y axis intersect = $d/($n.Y) = \*(Aq, $d/($n.Y), "\en";
\&
\&    print "VectorReal and MatrixReal interaction\en\en";
\&    use Math::MatrixReal;  # Not required for pure vector math as above
\&
\&    $r = $a\->vector2matrix_row;  # convert to MatrixReal Row Vector
\&    $c = $a\->vector2matrix_col;  # convert to MatrixReal Column Vector
\&    print \*(AqVector as a MatrixReal Row $r (vector \-> matrix) => \*(Aq, "\en", $r;
\&    print \*(AqVector as a MatrixReal Col $c (vector \-> matrix) => \*(Aq, "\en", $c;
\&
\&    $nx = $a\->norm;   $ny = $nx x Z;  $nz = $nx x $ny; # orthogonal vectors
\&    $R = vector_matrix( $nx, $ny, $nz );   # make the rotation matrix
\&    print \*(AqRotation Matrix from 3 Vectors   $R   => \*(Aq,"\en", $R, "\en";
\&
\&    print "Extract the Y row from the matrix as a VectorReal..\en";
\&    print \*(Aq$R\->matrix_row2vector(1) => \*(Aq, $R\->matrix_row2vector(1), "\en";
\&
\&    print "Rotate a vector with above rotation matrix\en";
\&    print \*(Aq$a * $R (vector \-> vector)\*(Aq,"\en", $a * $R, "\en";
\&
\&    print "Rotate a MatrixReal column (post multiply)...\en";
\&    print "(NB: matrix must be transposed (~) to match column format)\en";
\&    print \*(Aq~$R * $c (col_matrix \-> col_matrix) =>\*(Aq,"\en", ~$R * $c, "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Math::VectorReal\*(C'\fR package defines a 3D mathematical \*(L"vector\*(R", in a way
that is compatible with the previous \s-1CPAN\s0 module \f(CW\*(C`Math::MatrixReal\*(C'\fR. However
it provides a more vector oriented set of mathematical functions and overload
operators, to the \f(CW\*(C`MatrixReal\*(C'\fR package.  For example the normal perl string
functions \*(L"x\*(R" and \*(L".\*(R" have been overloaded to allow vector cross and dot
product operations. Vector math formula thus looks like vector math formula in
perl programs using this package.
.PP
While this package is compatible with Math::MatrixReal, you \s-1DO\s0 \s-1NOT\s0 need to
have that package to perform purely vector orientated calculations. You will
need it however if you wish to do matrix operations with these vectors. The
interface has been designed with this package flexibility in mind.
.PP
The vectors are defined in the same way as a \*(L"row\*(R" \f(CW\*(C`Math::MatrixReal\*(C'\fR matrix,
instead of that packages choice of \*(L"column\*(R" definition for vector operations.
Such vectors are multiplied to matices with the vector on the left and the
matrix on the right. \s-1EG:\s0   v * M \-> 'v
.PP
Not only is this the way I prefer to handle vectors, but it is the way most
graphics books use vectors. As a bonus it results in no overload conflicts
between this package and that of Math::MatrixReal, (the left objects overload
operator is called to do the mathematics). It also is a lot simpler than
\&\f(CW\*(C`MatrixReal\*(C'\fR column vector methods, which were designed for equation solving
rather than 3D geometry operations.
.PP
The  \fIvector_matrix()\fR  function provided, simplifies the creation a
\&\f(CW\*(C`MatrixReal\*(C'\fR object from 3 (usually orthogonal) vectors. This with its vector
orientated math operators makes it very easy to define orthogonal rotation
matrices from \f(CW\*(C`Math::VectorReal\*(C'\fR objects.  See a rough example in the
synopsis above, or in the file \*(L"matrix_test\*(R" in the packages source.
.PP
\&\s-1NOTE:\s0 the 6th element the \f(CW\*(C`Math::MatrixReal\*(C'\fR array object is used to hold the
length of the vector so that it can be re-used without needing to be
re-calculated all the time. This means the expensive \fIsqrt()\fR function, need not
be called unless nessary.  This usage should not effect the direct use of
these objects in the \f(CW\*(C`Math::MatrixReal\*(C'\fR functions.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
Four constant vectors are available for export (using an \*(L":all\*(R" tag).
these are
.PP
.Vb 4
\&    0 = [ 0 0 0 ]   the zero vector or origin
\&    X = [ 1 0 0 ]   |
\&    Y = [ 0 1 0 ]    > Unit axis vectors
\&    Z = [ 0 0 1 ]   |
.Ve
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.IP "new(x,y,z)" 4
.IX Item "new(x,y,z)"
Create a new vector with the values of \f(CW\*(C`x\*(C'\fR, \f(CW\*(C`y\*(C'\fR, \f(CW\*(C`z\*(C'\fR returning the
appropriate object.
.IP "vector(x,y,z)" 4
.IX Item "vector(x,y,z)"
As \f(CW\*(C`new\*(C'\fR but is a exported function which does not require a package
reference to create a \f(CW\*(C`Math::VectorReal\*(C'\fR object.
.IP "\fIclone()\fR" 4
.IX Item "clone()"
Return a completely new copy of the referring \f(CW\*(C`Math::VectorReal\*(C'\fR object.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fIarray()\fR" 4
.IX Item "array()"
Return the x,y,z elements of the referring vector are an array of values.
.IP "x()" 4
.IX Item "x()"
Return the x element of the referring vector.
.IP "y()" 4
.IX Item "y()"
Return the y element of the referring vector.
.IP "z()" 4
.IX Item "z()"
Return the z element of the referring vector.
.IP "stringify( [ \s-1FORMAT\s0 ] )" 4
.IX Item "stringify( [ FORMAT ] )"
Return the referring verctor as a string. The \f(CW\*(C`FORMAT\*(C'\fR if given is used
to sprintf format the vector. This is used for all VectorReal to String
conversions.
.Sp
By default this format is the same as it would be for a \f(CW\*(C`Math::MatrixReal\*(C'\fR
object, \*(L"[ %#19.12E %#19.12E %#19.12E ]\en\*(R".  Note that this includes a newline
character!.
.Sp
However unlike \f(CW\*(C`Math::MatrixReal\*(C'\fR you can assign a new default sprintf
format by assigning it to the packages \f(CW$FORMAT\fR variable. For Example
.Sp
.Vb 1
\&   $Math::VectorReal::FORMAT = "{ %g, %g, %g }"
.Ve
.Sp
Which is a good format to output vectors for use by the POVray (Persistance of
Vision Raytracer) program.
.IP "\fIlength()\fR" 4
.IX Item "length()"
Return the length of the given vector. As a side effect the length is saved
into that vectors object to avoid the use of the expensive \fIsqrt()\fR function.
.IP "\fInorm()\fR" 4
.IX Item "norm()"
Normalise the Vector. That is scalar divide the vector by its length, so that
it becomes of length one.  Normal vectors are commonly use to define
directions, without scale, or orientation of a 3 dimensional plane.
.IP "plane( v1, v2, v3 )" 4
.IX Item "plane( v1, v2, v3 )"
Given three points defined counter clockwise on a plane, return an array in
which the first element is the planes normal unit vector, and the second its
distance from the origin, along that vector.  \s-1NOTE:\s0 the distance may be
negitive, in which case the origon is above the defined plane in 3d space.
.IP "vector_matrix( nx, ny, nz )" 4
.IX Item "vector_matrix( nx, ny, nz )"
Given the new location for the X, Y and Z vectors, concatanate them together
(row wise) to create a \f(CW\*(C`Math::MatrixReal\*(C'\fR translation matrix. For example
if the 3 vectors are othogonal to each other, the matrix created will be
a rotation matrix to rotate the X, Y and Z axis to the given vectors. See
above for an example.
.SH "VECTOR/MATRIX CONVERSION"
.IX Header "VECTOR/MATRIX CONVERSION"
The following functions provide links between the \f(CW\*(C`Math::VectorReal\*(C'\fR and
\&\f(CW\*(C`Math::MatrixReal\*(C'\fR packages.
.PP
\&\s-1NOTE:\s0 While this package is closely related to \f(CW\*(C`Math::MatrixReal\*(C'\fR, it does
\&\s-1NOT\s0 require that that package to be installed unless you actually want to
perform matrix operations.
.PP
Also the overload operations will automatically handle vector/matrix
mathematics (See below).
.Sh "Vector to Matrix Conversion"
.IX Subsection "Vector to Matrix Conversion"
.IP "vector2matrix_row( [\s-1CLASS\s0] )" 4
.IX Item "vector2matrix_row( [CLASS] )"
.PD 0
.IP "vector2matrix_col( [\s-1CLASS\s0] )" 4
.IX Item "vector2matrix_col( [CLASS] )"
.PD
Convert \f(CW\*(C`Math::VectorReal\*(C'\fR objects to a \f(CW\*(C`Math::MatrixReal\*(C'\fR objects.
Optional argument defines the object class to be returned (defaults to
\&\f(CW\*(C`Math::MatrixReal\*(C'\fR).
.Sp
Note that as a \f(CW\*(C`Math::VectorReal\*(C'\fR is internally equivelent to a
\&\f(CW\*(C`Math::MatrixReal\*(C'\fR row matrix, \f(CW\*(C`vector2matrix_row\*(C'\fR is essentually just a
bless operation, which is \s-1NOT\s0 required to use with \f(CW\*(C`Math::MatrixReal\*(C'\fR
functions.
.Sp
The \f(CW\*(C`vector2matrix_col\*(C'\fR performs the required transpose to convert the
\&\f(CW\*(C`Math::VectorReal\*(C'\fR object into a \f(CW\*(C`Math::MatrixReal\*(C'\fR version of a vector (a
column matrix).
.Sh "Matrix to Vector Conversion"
.IX Subsection "Matrix to Vector Conversion"
.IP "matrix_row2vector( [\s-1ROW\s0] )" 4
.IX Item "matrix_row2vector( [ROW] )"
.PD 0
.IP "matrix_col2vector( [\s-1COLUMN\s0] )" 4
.IX Item "matrix_col2vector( [COLUMN] )"
.PD
When referred to by a \f(CW\*(C`Math::MatrixReal\*(C'\fR object, extracts the vector
from the matrix. the optional argument defines which row or column of the
matrix is to be extracted as a \f(CW\*(C`Math::VectorReal\*(C'\fR vector.
.SH "OPERATOR OVERLOADING"
.IX Header "OPERATOR OVERLOADING"
Overload operations are provided to perform the usual string conversion,
addition, subtraction, unary minus, scalar multiplation & division.  On top of
this however the multiply have been expanded to look for and execute
\&\f(CW\*(C`MatrixReal\*(C'\fR multiplation.
.PP
The Main purpose of this package however was to provide the special vector
product operations: dot product \*(L".\*(R" and cross product \*(L"x\*(R".  In perl these
operations are normally used for string operations, but if either argument
is a \f(CW\*(C`VectorReal\*(C'\fR object, the operation will attempt the approprate
vector math operation instead.
.PP
Note however that if one side of the dot \*(L".\*(R" operator is already a string,
then the vector will be converted to a sting and a string concatantion will be
performed. The cross operator \*(L"x\*(R" will just \fIcroak()\fR as it is non-sensical to
either repeat the string conversion of a vector, \s-1OR\s0 to repeat a string,
vector, times!
.PP
Overloaded operator summery...
    neg     unary minus \- multiply vector by \-1
     ""     automatic string conversion using \fIstringify()\fR function
      +     vector addition
      \-     vector subtraction
      /     scalar division (left argument must be the vector)
      *     scalar multiplication \s-1OR\s0 MatrixReal multiplication
      x     vector/cross product of two vectors
      .     dot product of two vectors \s-1OR\s0 vector/string concatanation
.PP
Posible future addition   '~'  to transpose a \f(CW\*(C`VectorReal\*(C'\fR into a
\&\f(CW\*(C`MatrixReal\*(C'\fR column vector (as per that operator on \f(CW\*(C`MatrixReal\*(C'\fR objects).
It was not added as it just did not seem to be needed.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The \f(CW\*(C`Math::MatrixReal\*(C'\fR \s-1CPAN\s0 Module by   Steffen Beyer
and the \f(CW\*(C`Math::MatrixReal\-Ext1\*(C'\fR \s-1CPAN\s0 extension by  Mike South
.SH "AUTHOR"
.IX Header "AUTHOR"
Anthony Thyssen <\fIanthony@cit.gu.edu.au\fR>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001 Anthony Thyssen. All rights reserved. This program is free
software; you can redistribute it and/or modify it under the same terms as
Perl itself. I would appreciate any suggestions however.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 198:" 4
.IX Item "Around line 198:"
You forgot a '=back' before '=head1'
.IP "Around line 200:" 4
.IX Item "Around line 200:"
\&'=item' outside of any '=over'
.IP "Around line 372:" 4
.IX Item "Around line 372:"
You forgot a '=back' before '=head2'
.IP "Around line 374:" 4
.IX Item "Around line 374:"
\&'=item' outside of any '=over'
