.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regression 3"
.TH Regression 3 "2016-02-11" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\&  Regression.pm \- weighted linear regression package (line+plane fitting)
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Statistics::Regression;
\&
\&  # Create regression object
\&  my $reg = Statistics::Regression\->new( 
\&    3, "sample regression", 
\&    [ "const", "someX", "someY" ] 
\&  );
\&
\&  # Add data points
\&  $reg\->include( 2.0, [ 1.0, 3.0, \-1.0 ] );
\&  $reg\->include( 1.0, [ 1.0, 5.0, 2.0 ] );
\&  $reg\->include( 20.0, [ 1.0, 31.0, 0.0 ] );
\&  $reg\->include( 15.0, [ 1.0, 11.0, 2.0 ] );
\&
\&  # Print the result
\&  $reg\->print(); 
\&
\&  # Prints the following:
\&  # ****************************************************************
\&  # Regression \*(Aqsample regression\*(Aq
\&  # ****************************************************************
\&  # Theta[0=\*(Aqconst\*(Aq]=       0.2950
\&  # Theta[1=\*(AqsomeX\*(Aq]=       0.6723
\&  # Theta[2=\*(AqsomeY\*(Aq]=       1.0688
\&  # R^2= 0.808, N= 4
\&  # ****************************************************************
\&
\&  # Or, to get the values of the coefficients and R^2
\&  my @theta = $reg\->theta;
\&  my $rsq   = $reg\->rsq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Regression.pm is a multivariate linear regression package.  That is, it
estimates the c coefficients for a line-fit of the type
.PP
y= c(0)*x(0) + c(1)*x1 + c(2)*x2 + ... + c(k)*xk
.PP
given a data set of N observations, each with k independent x variables and one
y variable.  Naturally, N must be greater than k\-\-\-and preferably considerably
greater.  Any reasonable undergraduate statistics book will explain what a
regression is.  Most of the time, the user will provide a constant ('1') as
x(0) for each observation in order to allow the regression package to fit an
intercept.
.SH "ALGORITHM"
.IX Header "ALGORITHM"
.Sh "Original Algorithm (\s-1ALGOL\-60\s0):"
.IX Subsection "Original Algorithm (ALGOL-60):"
.Vb 3
\&        W.  M.  Gentleman, University of Waterloo, "Basic Description
\&        For Large, Sparse Or Weighted Linear Least Squares Problems
\&        (Algorithm AS 75)," Applied Statistics (1974) Vol 23; No. 3
.Ve
.Sh "\s-1INTERNALS\s0"
.IX Subsection "INTERNALS"
R=Rbar is an upperright triangular matrix, kept in normalized
form with implicit 1's on the diagonal.  D is a diagonal scaling
matrix.  These correspond to \*(L"standard Regression usage\*(R" as
.PP
.Vb 1
\&                X\*(Aq X  = R\*(Aq D R
.Ve
.PP
A backsubsitution routine (in thetacov) allows to invert the R
matrix (the inverse is upper-right triangular, too!). Call this
matrix H, that is H=R^(\-1).
.PP
.Vb 2
\&          (X\*(Aq X)^(\-1) = [(R\*(Aq D^(1/2)\*(Aq) (D^(1/2) R)]^(\-1)
\&          = [ R^\-1 D^(\-1/2) ] [ R^\-1 D^(\-1/2) ]\*(Aq
.Ve
.Sh "Remarks"
.IX Subsection "Remarks"
This algorithm is the statistical \*(L"standard.\*(R" Insertion of a new observation
can be done one obs at any time (\s-1WITH\s0 A \s-1WEIGHT\s0!), and still only takes a low
quadratic time.  The storage space requirement is of quadratic order (in the
indep variables). A practically infinite number of observations can easily be
processed!
.SH "METHODS"
.IX Header "METHODS"
.Sh "new"
.IX Subsection "new"
.Vb 1
\& my $reg = Statistics::Regression\->new($n, $name, \e@var_names)
.Ve
.PP
Receives the number of variables on each observations (i.e., an integer) and
returns the blessed data structure as a Statistics::Regression object. Also
takes an optional name for this regression to remember, as well as a reference
to a k*1 array of names for the X coefficients.
.Sh "dump"
.IX Subsection "dump"
.Vb 1
\&  $reg\->dump
.Ve
.PP
Used for debugging.
.Sh "print"
.IX Subsection "print"
.Vb 1
\&  $reg\->print
.Ve
.PP
prints the estimated coefficients, and R^2 and N. For an example see the
\&\s-1SYNOPSIS\s0.
.Sh "include"
.IX Subsection "include"
.Vb 1
\&  $n = $reg\->include( $y, [ $x1, $x2, $x3 ... $xk ], $weight );
.Ve
.PP
Add one new observation. The weight is optional. Note that inclusion with a
weight of \-1 can be used to delete an observation.
.PP
Returns the number of observations so far included.
.Sh "theta"
.IX Subsection "theta"
.Vb 2
\&  $theta = $reg\->theta
\&  @theta = $reg\->theta
.Ve
.PP
Estimates and returns the vector of coefficients. In scalar context returns an
array reference; in list context it returns the list of coefficients.
.Sh "rsq, adjrsq, sigmasq, ybar, sst, k, n"
.IX Subsection "rsq, adjrsq, sigmasq, ybar, sst, k, n"
.Vb 1
\&  $rsq = $reg\->rsq; # etc...
.Ve
.PP
These methods provide common auxiliary information.  rsq, adjrsq,
sigmasq, sst, and ybar have not been checked but are likely correct.
The results are stored for later usage, although this is somewhat
unnecessary because the computation is so simple anyway.
.SH "BUGS/PROBLEMS"
.IX Header "BUGS/PROBLEMS"
.IP "Missing" 4
.IX Item "Missing"
This package lacks routines to compute the standard errors of
the coefficients.  This requires access to a matrix inversion
package, and I do not have one at my disposal.  If you want to
add one, please let me know.
.IP "Perl Problem" 4
.IX Item "Perl Problem"
perl is unaware of \s-1IEEE\s0 number representations.  This makes it a
pain to test whether an observation contains any missing
variables (coded as 'NaN' in Regression.pm).
.SH "VERSION"
.IX Header "VERSION"
0.15
.SH "AUTHOR"
.IX Header "AUTHOR"
Naturally, Gentleman invented this algorithm.  Adaptation by ivo welch. Alan
Miller (alan@dmsmelb.mel.dms.CSIRO.AU) pointed out nicer ways to compute the
R^2. Ivan Tubert-Brohman helped wrap the module as as standard \s-1CPAN\s0
distribution.
.SH "LICENSE"
.IX Header "LICENSE"
This module is released for free public use under a \s-1GPL\s0 license.
.PP
(C) Ivo Welch, 2001,2004.
