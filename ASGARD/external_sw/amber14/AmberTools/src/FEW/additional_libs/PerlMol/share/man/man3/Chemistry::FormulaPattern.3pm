.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Chemistry::FormulaPattern 3"
.TH Chemistry::FormulaPattern 3 "2016-02-11" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Chemistry::FormulaPattern \- Match molecule by formula
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Chemistry::FormulaPattern;
\&
\&    # somehow get a bunch of molecules...
\&    use Chemistry::File::SDF;
\&    my @mols = Chemistry::Mol\->read("file.sdf");
\&
\&    # we want molecules with six carbons and 8 or more hydrogens
\&    my $patt = Chemistry::FormulaPattern\->new("C6H8\-");
\&
\&    for my $mol (@mols) {
\&        if ($patt\->match($mol)) {
\&            print $mol\->name, " has a nice formula!\en";
\&        }
\&    }
\&
\&    # a concise way of selecting molecules with grep
\&    my @matches = grep { $patt\->match($mol) } @mols;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements a simple language for describing a range of
molecular formulas and allows one to find out whether a molecule matches
the formula specification. It can be used for searching for molecules by
formula, in a way similar to the \s-1NIST\s0 WebBook formula search
(<http://webbook.nist.gov/chemistry/form\-ser.html>). Note however that the
language used by this module is different from the one used by the WebBook!
.PP
Chemistry::FormulaPattern shares the same interface as Chemistry::Pattern.
To perform a pattern matching operation on a molecule, follow these steps.
.PP
1) Create a pattern object, by parsing a string. Let's assume that the pattern
object is stored in \f(CW$patt\fR and that the molecule is \f(CW$mol\fR.
.PP
2) Execute the pattern on the molecule by calling \f(CW$patt\fR\->match($mol).
.PP
If \f(CW$patt\fR\->match returns true, there was a match. If \f(CW$patt\fR\->match is called two
consecutive times with the same molecule, it returns false; then true (if there
is a match), then false, etc. This is because the Chemistry::Pattern interface
is designed to allow multiple matches for a given molecule, and then returns
false when there are no further matches; in the case of a formula pattern,
there is only one possible match.
.PP
.Vb 5
\&    $patt\->match($mol); # may return true
\&    $patt\->match($mol); # always false
\&    $patt\->match($mol); # may return true
\&    $patt\->match($mol); # always false
\&    # ...
.Ve
.PP
This allows one two use the standard while loop for all kinds of patterns
without having to worry about endless loops:
.PP
.Vb 5
\&    # $patt might be a Chemistry::Pattern, Chemistry::FormulaPattern,
\&    # or Chemistry::MidasPattern object
\&    while ($patt\->match($mol)) {
\&        # do something
\&    }
.Ve
.PP
Also note that formula patterns don't really have the concept of an atom map,
so \f(CW$patt\fR\->atom_map and \f(CW$patt\fR\->bond_map always return the empty list.
.SH "FORMULA PATTERN LANGUAGE"
.IX Header "FORMULA PATTERN LANGUAGE"
In the simplest case, a formula pattern may be just a regular formula, as
used by the Chemistry::File::Formula module. For example, the pattern
\&\*(L"C6H6\*(R" will only match molecules with six carbons, six hydrogens, and no other
atoms.
.PP
The interesting thing is that one can also specify ranges for the elements, 
as two hyphen-separated numbers. \*(L"C6H8\-10\*(R" will match molecules with six
carbons and eight to ten hydrogens.
.PP
Ranges may also be open, by omitting the upper part of the range. \*(L"C6H0\-\*(R" will
match molecules with six carbons and any number of hydrogens (i.e., zero or
more).
.PP
A formula pattern may also allow for unspecified elements by means of the
asterisk special character, which can be placed anywhere in the formula
pattern. For example, \*(L"C2H6*\*(R" (or "C2*H6, etc.) will match C2H6, and also
C2H6O, C2H6S, C2H6SO, etc.
.PP
Ranges can also be used after a subformula in parentheses: \*(L"(\s-1CH2\s0)1\-2\*(R" will
match molecules with one or two carbons and two to four hydrogens. Note,
however, that the \*(L"structure\*(R" of the bracketed part of the formula is
forgotten, i.e., the multiplier applies to each element individually and does
not have to be an integer. That is, the above pattern will match \s-1CH2\s0, \s-1CH3\s0, \s-1CH4\s0,
C2H2, C2H3, and C2H4.
.SH "VERSION"
.IX Header "VERSION"
0.10
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Chemistry::Pattern
.PP
The PerlMol website <http://www.perlmol.org/>
.SH "AUTHOR"
.IX Header "AUTHOR"
Ivan Tubert-Brohman <itub@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004 Ivan Tubert-Brohman. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same terms as
Perl itself.
